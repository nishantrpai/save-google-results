{"version":3,"file":"contentScript.js","mappings":";;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAqD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAqD;AAC7E;AACA;AACA,MAAM;AACN;AACA;AACA,wBAAwB,qDAAqD;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,6BAA6B;AAC7E,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uDAAuD,UAAU,sBAAsB,wBAAwB;AAC/G;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4CAA4C;AAC5E;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA,uCAAuC,uCAAuC;AAC9E;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,CAAC,sBAAsB,gCAAgC;;AAEvD,oE","sources":["webpack://thread2audio/./src/contentScript.js"],"sourcesContent":["// Google Search Results Collector Chrome Extension\n// Automatically collects search results as you browse Google and allows CSV export\n\n// @ts-ignore - Chrome extension APIs\nconst chromeAPI = typeof chrome !== 'undefined' ? chrome : null;\n\nlet isProcessing = false;\nlet currentUrl = window.location.href;\nlet isCollectionActive = false;\n\n// Storage keys\nconst STORAGE_KEY_CONTENT = 'google_search_results';\nconst ACTIVE_KEY_CONTENT = 'google_collector_active';\n\n// Utility function to clean text\nfunction clean(text) {\n    return (text || '').replace(/\\s+/g, ' ').replace(/\"/g, \"'\").trim();\n}\n\n// Check if collection is active\nasync function checkCollectionStatus() {\n    try {\n        if (chromeAPI && chromeAPI.storage) {\n            const result = await chromeAPI.storage.local.get([ACTIVE_KEY_CONTENT]);\n            isCollectionActive = result[ACTIVE_KEY_CONTENT] || false;\n        } else {\n            const stored = localStorage.getItem(ACTIVE_KEY_CONTENT);\n            isCollectionActive = stored === 'true';\n        }\n        return isCollectionActive;\n    } catch (error) {\n        console.error('Error checking collection status:', error);\n        return false;\n    }\n}\n\n// Get stored results from Chrome storage\nasync function getStoredResults() {\n    try {\n        if (chromeAPI && chromeAPI.storage) {\n            const result = await chromeAPI.storage.local.get([STORAGE_KEY_CONTENT]);\n            return result[STORAGE_KEY_CONTENT] || {\n                metadata: { queries: [], totalPages: 0, collectionStarted: null },\n                results: [['title', 'link', 'description', 'page', 'timestamp']]\n            };\n        }\n        // Fallback to localStorage if Chrome storage not available\n        const stored = localStorage.getItem(STORAGE_KEY_CONTENT);\n        return stored ? JSON.parse(stored) : {\n            metadata: { queries: [], totalPages: 0, collectionStarted: null },\n            results: [['title', 'link', 'description', 'page', 'timestamp']]\n        };\n    } catch (error) {\n        console.error('Error getting stored results:', error);\n        return {\n            metadata: { queries: [], totalPages: 0, collectionStarted: null },\n            results: [['title', 'link', 'description', 'page', 'timestamp']]\n        };\n    }\n}\n\n// Save results to Chrome storage\nasync function saveResults(data) {\n    try {\n        if (chromeAPI && chromeAPI.storage) {\n            await chromeAPI.storage.local.set({ [STORAGE_KEY_CONTENT]: data });\n        } else {\n            // Fallback to localStorage\n            localStorage.setItem(STORAGE_KEY_CONTENT, JSON.stringify(data));\n        }\n    } catch (error) {\n        console.error('Error saving results:', error);\n    }\n}\n\n// Extract search query from URL\nfunction getSearchQuery() {\n    const urlParams = new URLSearchParams(window.location.search);\n    return clean(urlParams.get('q') || 'unknown query');\n}\n\n// Extract page number from URL\nfunction getPageNumber() {\n    const urlParams = new URLSearchParams(window.location.search);\n    const start = urlParams.get('start');\n    return start ? Math.floor(parseInt(start) / 10) + 1 : 1;\n}\n\n// Process search results on current page\nasync function processResults() {\n    if (isProcessing || !isCollectionActive) return 0;\n    isProcessing = true;\n\n    try {\n        const data = await getStoredResults();\n        const results = [...document.querySelectorAll('div.tF2Cxc')];\n        let newCount = 0;\n        \n        const query = getSearchQuery();\n        const page = getPageNumber();\n        const timestamp = new Date().toISOString();\n\n        // Add query to metadata if not already present\n        if (!data.metadata.queries.includes(query)) {\n            data.metadata.queries.push(query);\n        }\n\n        // Update metadata\n        data.metadata.totalPages = Math.max(data.metadata.totalPages, page);\n        if (!data.metadata.collectionStarted) {\n            data.metadata.collectionStarted = timestamp;\n        }\n\n        results.forEach(r => {\n            const titleElement = r.querySelector('h3');\n            const linkElement = r.querySelector('a');\n            const descElement = r.querySelector('.VwiC3b');\n\n            const title = clean(titleElement?.textContent || 'no title');\n            const link = clean(linkElement?.href || 'no link');\n            const description = clean(descElement?.textContent || 'no description');\n            \n            // Check if this result already exists to avoid duplicates\n            const exists = data.results.some(row => row[1] === link);\n            if (!exists && link !== 'no link') {\n                data.results.push([title, link, description, page, timestamp]);\n                newCount++;\n            }\n        });\n        \n        await saveResults(data);\n        console.log(`Google Results Collector: Added ${newCount} new results. Total: ${data.results.length - 1}`);\n        return newCount;\n    } catch (error) {\n        console.error('Error processing results:', error);\n        return 0;\n    } finally {\n        isProcessing = false;\n    }\n}\n\n// Download CSV file\nasync function downloadCSV() {\n    try {\n        const data = await getStoredResults();\n        \n        if (data.results.length <= 1) {\n            return; // No data to download\n        }\n        \n        // Create CSV with metadata rows at the top\n        const csvRows = [];\n        \n        // Add metadata as visible rows in the CSV\n        csvRows.push(['Collection Info', '', '', '', '']);\n        csvRows.push(['Generated', new Date().toISOString(), '', '', '']);\n        csvRows.push(['Collection Started', data.metadata.collectionStarted || 'Unknown', '', '', '']);\n        csvRows.push(['Total Results', (data.results.length - 1).toString(), '', '', '']);\n        csvRows.push(['Total Pages', data.metadata.totalPages.toString(), '', '', '']);\n        csvRows.push(['Queries', data.metadata.queries.join(' | '), '', '', '']);\n        csvRows.push(['', '', '', '', '']); // Empty separator row\n        \n        // Add the header row and data\n        csvRows.push(...data.results);\n        \n        // Convert to CSV string\n        const csvContent = csvRows.map(row => \n            row.map(cell => `\"${(cell || '').toString().replace(/\"/g, '\"\"')}\"`).join(',')\n        ).join('\\n');\n        \n        const blob = new Blob([csvContent], { type: 'text/csv' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `google_results_${new Date().toISOString().split('T')[0]}.csv`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n        \n    } catch (error) {\n        console.error('Error downloading CSV:', error);\n    }\n}\n\n// Clear all stored results\nasync function clearResults() {\n    try {\n        if (chromeAPI && chromeAPI.storage) {\n            await chromeAPI.storage.local.remove([STORAGE_KEY_CONTENT]);\n        } else {\n            localStorage.removeItem(STORAGE_KEY_CONTENT);\n        }\n        console.log('Google Results Collector: Cleared all stored results');\n    } catch (error) {\n        console.error('Error clearing results:', error);\n    }\n}\n\n// Update button text with current count - removed (managed by popup)\nasync function updateButtonText() {\n    // Function removed - UI now managed by popup\n}\n\n// Show notification to user - removed (managed by popup)\nfunction showNotification(message, color = 'hsl(0 0% 15%)') {\n    // Function removed - notifications now managed by popup\n}\n\n// Create control buttons - removed (managed by popup)\nasync function createButtons() {\n    // Function removed - UI now managed by popup\n}\n\n// Remove control buttons - removed (managed by popup)\nfunction removeButtons() {\n    // Function removed - UI now managed by popup\n}\n\n// Listen for messages from popup\nif (chromeAPI && chromeAPI.runtime) {\n    chromeAPI.runtime.onMessage.addListener((message, sender, sendResponse) => {\n        if (message.action === 'start') {\n            startCollection();\n        } else if (message.action === 'stop') {\n            stopCollection();\n        }\n        return true;\n    });\n}\n\n// Start collection\nasync function startCollection() {\n    isCollectionActive = true;\n    await main();\n}\n\n// Stop collection\nasync function stopCollection() {\n    isCollectionActive = false;\n}\n\n// Main processing function\nasync function main() {\n    console.log('Google Results Collector: Processing page');\n    \n    // Only process if we're on a Google search results page\n    if (!window.location.href.includes('/search')) {\n        return;\n    }\n\n    // Check collection status\n    await checkCollectionStatus();\n\n    // Only process results if collection is active\n    if (!isCollectionActive) {\n        return;\n    }\n\n    const newResults = await processResults();\n}\n\n// Set up mutation observer for dynamic content\nfunction observeChanges() {\n    const observer = new MutationObserver((mutations) => {\n        const hasNewResults = mutations.some(mutation => \n            Array.from(mutation.addedNodes).some(node => \n                node.nodeType === 1 && \n                ((node instanceof Element && node.querySelector && node.querySelector('.tF2Cxc')) || \n                 (node instanceof Element && node.classList && node.classList.contains('tF2Cxc')))\n            )\n        );\n        \n        if (hasNewResults) {\n            setTimeout(main, 500); // Small delay to ensure DOM is stable\n        }\n    });\n\n    observer.observe(document.body, {\n        childList: true,\n        subtree: true\n    });\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', main);\n} else {\n    main();\n}\n\n// Set up change detection\nobserveChanges();\n\n// Handle navigation changes\nlet lastUrl = window.location.href;\nnew MutationObserver(() => {\n    const currentUrl = window.location.href;\n    if (currentUrl !== lastUrl) {\n        lastUrl = currentUrl;\n        setTimeout(main, 1000); // Delay to allow page to load\n    }\n}).observe(document, { subtree: true, childList: true });\n\nconsole.log('Google Results Collector: Extension loaded and ready');"],"names":[],"sourceRoot":""}